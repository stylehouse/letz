// to navigate the gap between nodes
import type { SvelteComponent } from 'svelte';
import { tick, setContext,getContext } from 'svelte';

import { ac, ahsk,ahk,theone,hak,haks,havs, dec,dig, sha256,sex,ex,nex,now,grep,grop,armap,map,sum,ksaf,hashkv,flatten,fatal,heq,reverse } from "$lib/Y/Pic.ts"
import { pit,C_,i_,o_,pito,o_path,o_up,inlace } from "$lib/St.svelte"
import {diff,enj,enL,deL,indents} from "$lib/Y/Text"
import { ontheclient } from "$lib/Sv.svelte"


# *.svelte do: g = Named("Such")
    export function Named(t, co) {
        !ontheclient() and return {}
        fatal.iske(t)
        co ||= {}
        $g = co.G || {}
        $Names = getContext('Names')
        $old = Names[t]
        Names[t] = g
        old and ex(g,old)
        g.t = t
        return g
    }
# *.svelte do: g = Send("Such",C)
    export function Send(t, C) {
        !ontheclient() and return {}
        $Names = getContext('Names')
        $Ag = Names[t]
        !Ag and return {}
        !Ag.input and debugger
        Ag.input(C)
        # give them the telephone?
        return {update: () => Ag.update && Ag.update()}
    }








# < html elements -> somewhere
# < universal drag+drop interactions for all Con
    export function locate_ev(ev) {
        $E = {N:[]}
        $ta = ev.target
        while (1) {
            E.N.unshift({t:ta.nodeName,ta})
            ta = ta.parentNode
            !ta || ta == document.body and break
        }
        return E
    }